name: Update Loon and Egern Rules

on:
  workflow_dispatch: # 允许手动触发
  schedule:
    - cron: "0 */6 * * *" # 每6小时运行一次

permissions:
  actions: write
  contents: write

jobs:
  UpdateRules:
    runs-on: ubuntu-latest
    env:
      TZ: Asia/Shanghai # 设置时区为中国

    steps:
      # 检出仓库
      - name: Checkout Repository
        uses: actions/checkout@v4.2.2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      # 下载 Loon 规则（保留 Emby）
      - name: Download Loon Rules
        run: |
          mkdir -p Loon/Rule Temp
          declare -A rules=(
            ["Telegram"]="https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Telegram/Telegram.list"
            ["YouTube"]="https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/YouTube/YouTube.list"
            ["Twitter"]="https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Twitter/Twitter.list"
            ["Spotify"]="https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Spotify/Spotify.list"
            ["AI"]="https://kelee.one/Tool/Loon/Rule/AI.list"
            ["TikTok"]="https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/TikTok/TikTok.list"
            ["Instagram"]="https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Instagram/Instagram.list"
            ["GitHub"]="https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/GitHub/GitHub.list"
            ["Emby"]="https://raw.githubusercontent.com/Repcz/Tool/refs/heads/X/Loon/Rules/Emby.list"
            ["Google"]="https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Google/Google.list"
          )
          for name in "${!rules[@]}"; do
            url=${rules[$name]}
            echo "Downloading $name from $url"
            if curl -L -H "User-Agent: Surge iOS/3450" "$url" -o "Temp/$name.list" --fail; then
              echo "$url" > "Temp/$name.url"
              echo "Successfully downloaded $name"
            else
              echo "Failed to download $name from $url" >> error.log
            fi
          done
          # 列出 Temp 目录内容以供调试
          ls -la Temp/ > temp_download_contents.log

      # 处理 Loon 规则（跳过 Emby 的 .url 处理并检查文件存在性）
      - name: Process Loon Rules
        run: |
          for file in Temp/*.list; do
            if [[ -f "$file" ]]; then
              file_names=$(basename "$file" .list)
              # 跳过 Emby 的 .url 文件处理或检查 .url 文件存在性
              if [[ "$file_names" == "Emby" ]]; then
                url="Skipped URL"
              elif [[ -f "Temp/$file_names.url" ]]; then
                url=$(cat "Temp/$file_names.url")
              else
                url="Unknown URL"
                echo "Warning: Temp/$file_names.url not found for $file_names" >> warning.log
              fi
              # 移除除引用链接、规则名称、规则统计外的其他元信息
              sed -i -E '/^# (AUTHOR|REPO|UPDATED|DOMAIN(-[A-Z]+)?|IP-[A-Z0-9]+|USER-AGENT|TOTAL):/d' "$file"
              # 移除 PROCESS-NAME
              sed -i -e '/^PROCESS-NAME/d' "$file"
              # 计算规则统计（总行数减去以 # 开头的行）
              line_count=$(grep -v '^#' "$file" | wc -l)
              # 创建临时文件，添加元信息
              {
                echo "# 引用链接: $url"
                echo "# 规则名称: $file_names"
                echo "# 规则统计: $line_count"
                echo ""
                cat "$file"
              } > tmpfile
              mv tmpfile "$file"
              # 移动到 Loon/Rule
              mv "$file" "Loon/Rule/$file_names.list"
            else
              echo "$file not found."
            fi
          done
          # 列出 Temp 目录内容以供调试
          ls -la Temp/ > temp_process_contents.log

      # 转换为 Egern 格式（跳过 Emby 的 .url 处理并检查文件存在性）
      - name: Convert to Egern Format
        run: |
          mkdir -p Egern/Rule
          for file in Loon/Rule/*.list; do
            if [[ -f "$file" ]]; then
              file_names=$(basename "$file" .list)
              yaml_file="Temp/$file_names.yaml"
              cp "$file" "$yaml_file"
              # 跳过 Emby 的 .url 文件处理或检查 .url 文件存在性
              if [[ "$file_names" == "Emby" ]]; then
                url="Skipped URL"
              elif [[ -f "Temp/$file_names.url" ]]; then
                url=$(cat "Temp/$file_names.url")
              else
                url="Unknown URL"
                echo "Warning: Temp/$file_names.url not found for $file_names" >> warning.log
              fi
              # 移除除引用链接、规则名称、规则统计外的其他元信息
              sed -i -E '/^# (AUTHOR|REPO|UPDATED|DOMAIN(-[A-Z]+)?|IP-[A-Z0-9]+|USER-AGENT|TOTAL):/d' "$yaml_file"
              # 第一部分：清理规则并添加集合标识
              sed -i -e '/^USER-AGENT/d' "$yaml_file"
              sed -i -e '/^PROCESS-NAME/d' "$yaml_file"
              sed -i -e '/^AND/d' "$yaml_file"
              sed -i -e '/^OR/d' "$yaml_file"
              sed -i -e '/^NOT/d' "$yaml_file"
              awk '/^DOMAIN,/ && !added {print "domain_set:"; added=1} {print}' "$yaml_file" > tmpfile && mv tmpfile "$yaml_file"
              awk '/^DOMAIN-SUFFIX,/ && !added {print "domain_suffix_set:"; added=1} {print}' "$yaml_file" > tmpfile && mv tmpfile "$yaml_file"
              awk '/^DOMAIN-KEYWORD,/ && !added {print "domain_keyword_set:"; added=1} {print}' "$yaml_file" > tmpfile && mv tmpfile "$yaml_file"
              awk '/^DOMAIN-WILDCARD,/ && !added {print "domain_wildcard_set:"; added=1} {print}' "$yaml_file" > tmpfile && mv tmpfile "$yaml_file"
              awk '/^IP-CIDR,/ && !added {print "ip_cidr_set:"; added=1} {print}' "$yaml_file" > tmpfile && mv tmpfile "$yaml_file"
              awk '/^IP-CIDR6,/ && !added {print "ip_cidr6_set:"; added=1} {print}' "$yaml_file" > tmpfile && mv tmpfile "$yaml_file"
              awk '/^IP-ASN,/ && !added {print "asn_set:"; added=1} {print}' "$yaml_file" > tmpfile && mv tmpfile "$yaml_file"
              awk '/^URL-REGEX,/ && !added {print "url_regex_set:"; added=1} {print}' "$yaml_file" > tmpfile && mv tmpfile "$yaml_file"
              awk '/^DEST-PORT,/ && !added {print "dest_port_set:"; added=1} {print}' "$yaml_file" > tmpfile && mv tmpfile "$yaml_file"
              awk '/^GEOIP,/ && !added {print "geoip_set:"; added=1} {print}' "$yaml_file" > tmpfile && mv tmpfile "$yaml_file"
              # 第二部分：格式化规则
              # 检查是否存在no-resolve变体
              has_no_resolve=false
              if grep -qE ',no-resolve|, no-resolve|\(no-resolve\)' "$yaml_file"; then
                has_no_resolve=true
              fi
              # 删除所有no-resolve及其变体
              sed -i -E 's/,?\s*\(?no-resolve\)?//g' "$yaml_file"
              # 格式化规则行
              sed -i -E 's/^(URL-REGEX,)([^,]+)$/\1"\2"/' "$yaml_file"
              sed -i -E 's/^(DOMAIN|DOMAIN-SUFFIX|DOMAIN-KEYWORD|DOMAIN-WILDCARD|DEST-PORT|IP-CIDR|IP-CIDR6|IP-ASN|URL-REGEX|GEOIP),/  - /g' "$yaml_file"
              # 添加no_resolve标识
              if [ "$has_no_resolve" = true ]; then
                sed -i '1i\no_resolve: true' "$yaml_file"
              fi
              # 计算规则统计（只统计以 "  - " 开头的规则行）
              line_count=$(grep -c '^  - ' "$yaml_file")
              # 创建临时文件，添加元信息
              {
                echo "# 引用链接: $url"
                echo "# 规则名称: $file_names"
                echo "# 规则统计: $line_count"
                echo ""
                cat "$yaml_file"
              } > tmpfile
              mv tmpfile "$yaml_file"
              # 移动到 Egern/Rule
              mv "$yaml_file" "Egern/Rule/$file_names.yaml"
            else
              echo "$file not found."
            fi
          done
          # 列出 Temp 目录内容以供调试
          ls -la Temp/ > temp_egern_contents.log
          rm -rf Temp

      # 提交更改
      - name: Commit Changes
        run: |
          git config user.name "GitHub Action"
          git config user.email "action@github.com"
          git add Loon/Rule/*.list Egern/Rule/*.yaml
          if git status -s | grep -q .; then
            git commit -m "Update Loon and Egern Rules $(date +'%Y-%m-%d %H:%M:%S')"
            git push
          else
            echo "No changes to commit."
          fi

      # 清理旧的工作流运行记录
      - name: Clean Workflow Runs
        uses: Mattraks/delete-workflow-runs@main
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          retain_days: 0
          keep_minimum_runs: 12